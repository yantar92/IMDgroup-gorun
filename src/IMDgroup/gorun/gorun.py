# MIT License
#
# Copyright (c) 2024-2025 Inverse Materials Design Group
#
# Author: Ihor Radchenko <yantar92@posteo.net>
#
# This file is a part of IMDgroup-gorun package
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.


"""Automate VASP job submission to Slurm queue from current VASP dir.
"""
import os
import sys
import re
import warnings
import argparse
import datetime
import time
import subprocess
import glob
from pathlib import Path
from termcolor import colored
from IMDgroup.gorun.slurm import\
    (barf_if_no_cmd, directory_queued_p,
     clear_slurm_logs, get_best_script, user_job_count)
from IMDgroup.gorun.cleanVASP import\
    (prepare_vasp_dir, nebp, mdp, directory_converged_p,
     directory_contains_vasp_outputp)
from IMDgroup.gorun.sbatch import\
    (barf_if_no_env, get_config, current_server, get_sbatch_args)


def _showwarning(message, category, _filename, _lineno, file=None, _line=None):
    """Print warning in nicer way."""
    output = colored(
        f"{category.__name__}: ", "yellow", attrs=['bold']) +\
        f"{message}"
    print(output, file=file or sys.stderr)


warnings.showwarning = _showwarning

PYTHON_HEADER = """
from ase.calculators.vasp import Vasp
from ase.io import read as ase_read
from IMDgroup.gorun.cleanVASP import generate_potcar

# Replace ASE's POTCAR generation with your function
def custom_write_potcar(self, suffix="", directory='.'):
    '''Use our generate_potcar function instead of ASE's'''
    generate_potcar(path=directory, keep_existing=False)

# POSCAR can be a copy of CONTCAR as needed
atoms = ase_read('POSCAR', format="vasp")
calc=Vasp(directory='.', atoms=atoms)

# Replace the method on this instance
calc.write_potcar = custom_write_potcar.__get__(calc, type(calc))

# Already copied from INCAR.X if necessary
calc.read_incar('INCAR')
# auto-generated by gorun if necessary
calc.read_potcar('POTCAR')
calc.read_kpoints('KPOINTS')
"""


def get_args():
    """Parse command line args and return arg dictionary."""
    argparser = argparse\
        .ArgumentParser(
            description=f"""Queue VASP run for current directory
Do nothing when VASP run is already queued or convrged for the current directory.
Also,
1. Make sure that vdw_kernel.bindat is copied over from VASP source dir
2. If CONTCAR is present, copy it over to POSCAR
3. Generate POTCAR file
4. Backup old VASP files and slurm logs

Also, when current dir contains INCAR.0, ICNAR.1, ... files
and the run is converged, replace INCAR with the first INCAR.X, and re-run.

When there is INCAR.py file, do not run VASP directly. Instead,
run VASP via ASE as the following:
{PYTHON_HEADER}
# <INCAR.py contents inserted here and can access atoms variable with calculator all set>
Srlurm script will be saved under name 'sub'.""",
            epilog="""Example:
gorun 2 24:00:00
- Submits a job requesting 2 nodes with a 24-hour time limit.""")

    argparser.add_argument(
        "number_of_nodes", help="number of nodes to request (optional)",
        nargs="?",
        default=None)
    argparser.add_argument(
        "time_limit",
        nargs="?",
        help="Time limit for the job in the format hh:mm:ss (optional)",
        default=None)
    argparser.add_argument(
        "--config",
        help="Path to configuration file " +
        "(default: $IMDGroup/dist/etc/gorun.toml)",
        default=None)
    argparser.add_argument(
        "--queue",
        help="Queue to be used (default: find best)",
        type=str,
        default=None)
    argparser.add_argument(
        "--vasp",
        help="Vasp executable to run (default: ncl)",
        type=str,
        choices=["ncl", "gam", "std"],
        default="ncl")
    argparser.add_argument(
        "--no_vasp_config",
        help="Whether to configure environment for VASP",
        action="store_true")
    argparser.add_argument(
        "--local",
        help="Whether to run locally (do not use sbatch)",
        action="store_true")
    argparser.add_argument(
        "--no_incar_py",
        help="Ignore INCAR.py",
        action="store_true")
    argparser.add_argument(
        "--mark",
        help="When set, do not invoke sbatch sub at the end,"
        " just check and create 'gorun_ready' file",
        action="store_true")
    argparser.add_argument(
        "--force",
        help="When provided, force running VASP",
        action="store_true")
    argparser.add_argument(
        "--keep_potcar",
        help="When POTCAR is already present, do not re-generate it",
        action="store_true")
    argparser.add_argument(
        "--no_clean",
        help="Do not clean the dir after backing up.",
        action="store_true")
    argparser.add_argument(
        "--max_slurm_jobs",
        help="Maximum of slurm jobs allowed to run simultaneously. "
        "Wait until squeue shortens below this number before running VASP.",
        type=int,
        default=0
    )
    return argparser.parse_args()


def get_next_run_folder() -> str:
    """Get the next available 'gorun_*' folder name."""
    prefix = 'gorun'
    existing_folders = glob.glob(prefix + "_*")
    # Extract numeric parts from folder names
    # and find the next available number
    run_numbers = [int(folder.split('_')[1])
                   for folder in existing_folders
                   if folder.split('_')[1].isdigit()]
    next_run_number = max(run_numbers) + 1 if run_numbers else 1
    return f"{prefix}_{next_run_number}_" +\
        datetime.datetime.now().strftime("%Y_%m_%dT%H_%M_%S")


def backup_current_dir(to: str) -> None:
    """Backup current directory to directory TO.
    """
    barf_if_no_cmd('rsync')
    print(f"Backing up {os.getcwd()}")
    if Path('gorun_ready').is_file():
        print("Found gorun_ready. Deleting")
        Path('gorun_ready').unlink()
    subprocess.check_call(f"rsync -q * './{to}'", shell=True)
    if nebp('.'):
        print("Detected NEB-like input")
        for dirname in os.listdir('.'):
            if os.path.isdir(dirname) and re.match(r'[0-9]+', dirname):
                subprocess.check_call(f"rsync -qr {dirname} './{to}'", shell=True)


def main():
    """Run the script."""
    barf_if_no_env("VASP_PATH")
    barf_if_no_env("VASP_PP_PATH")
    args = get_args()
    config = get_config(args)
    server = current_server(config)
    queues = config[server]['queues']
    if args.queue is not None:
        queues = [args.queue]

    if server is None:
        print(colored(
            'Running on unknown server. Please adjust the config.',
            "red"))
        return 1

    if Path('gorun_ready').is_file() and not args.force:
        print(colored(
            "gorun_ready file present. "
            "Exiting without submitting a new job.",
            "yellow"))
        # This is useful to return normally here as
        # the purpose of gorun is achieved.
        return 0

    working_dir = os.getcwd()
    if directory_queued_p(working_dir) and not args.force:
        print(colored(
            "A job is already running in this directory. "
            "Exiting without submitting a new job.",
            "yellow"))
        # This is useful to return normally here as
        # the purpose of gorun is achieved.
        return 0

    if not os.path.isfile('INCAR'):
        print(colored(
            'No INCAR found in current dir. '
            'Exiting without submitting a new job.',
            "yellow"))
        return 1

    extra_incars = None
    if not mdp('.') and directory_converged_p('.') and not args.force:
        extra_incars = sorted(list(Path('.').glob(r"INCAR.[0-9]*")))
        if len(extra_incars) > 0:
            print(colored(
                f"Converged, but found additional INCARs: {extra_incars}"
                f" Replacing INCAR with {extra_incars[0]}",
                "yellow"))
        else:
            print(colored(
                'VASP run already converged. '
                'Exiting without submitting a new job.',
                "yellow"))
            return 1

    if args.max_slurm_jobs > 0 and not args.local:
        while user_job_count() >= args.max_slurm_jobs:
            print("Waiting for submitted jobs to finish")
            time.sleep(10)

    if directory_contains_vasp_outputp('.'):
        run_folder = get_next_run_folder()
        backup_current_dir(run_folder)

    if extra_incars is not None:
        Path('INCAR').rename('INCAR.old')
        extra_incars[0].rename('INCAR')

    prepare_vasp_dir('.', args.keep_potcar)
    if nebp('.'):
        for dirname in sorted(os.listdir('.')):
            if os.path.isdir(dirname) and re.match(r'[0-9]+', dirname):
                prepare_vasp_dir(dirname)

    if not args.no_clean:
        clear_slurm_logs('.')
        if nebp('.'):
            for dirname in sorted(os.listdir('.')):
                if os.path.isdir(dirname) and re.match(r'[0-9]+', dirname):
                    clear_slurm_logs(dirname)

    if not args.no_incar_py and Path('INCAR.py').is_file():
        print(colored(
           "Found INCAR.py.  Using instead of directly running VASP.",
           "yellow"))
        base_script = f"""{config[server]['VASP-setup'] if not args.no_vasp_config else ""}"""\
            '\nexport VASP_COMMAND="gorun --local --no_incar_py --force --no_clean"'\
            "\npython <<EOF"\
            f"\n{PYTHON_HEADER}"\
            "\n$(cat INCAR.py)"\
            "\nEOF"
    else:
        base_script = f"""{config[server]['VASP-setup'] if not args.no_vasp_config else ""}"""\
            f'''\nexport VASP_COMMAND="{config[server].get('mpiexec', 'mpiexec')} {os.environ["VASP_PATH"]}/bin/vasp_{args.vasp}"'''\
            "\n$VASP_COMMAND"
    shebang = config[server].get('shebang', "#!/usr/bin/bash")
    if args.local:
        script = f"{shebang}\n{base_script}"
    else:
        script = get_best_script(
            [get_sbatch_args(args, config, server, queue) for queue in queues],
            base_script,
            shebang)
        with open('sub', 'w', encoding='utf-8') as f:
            f.write(script)

    # Submit the job using sbatch.
    if args.mark:
        Path('gorun_ready').touch()
        print(colored(
            'Created "gorun_ready" file.'
            '  Invoke "sbatch sub" to submit manually.',
            "green"))
    elif args.local:
        with open("vasp.out", "a", encoding='utf-8') as f:
            subprocess.run(
                script,
                shell=True,
                check=True,
                stdout=f,
                stderr=f,
                text=True
            )
        # os.system("bash sub > vasp.out 2>&1")
        print(colored('Running job locally...', "green"))
    else:
        status = os.WEXITSTATUS(os.system("sbatch sub"))
        if status == 0:
            print(colored('Job submitted to SLURM scheduler.', "green"))
        else:
            print(colored('Failed to submit to SLURM scheduler.', "red"))
    return 0
